#version 450
#extension GL_GOOGLE_include_directive : enable

#define VERTEX_PROGRAM
#include "global.h"

layout (constant_id = 0) const int vbo_mode = 0;
layout (constant_id = 1) const int light_mode = 0;

#if defined(USE_FOG) || defined(USE_ENV)
layout(set = 0, binding = 0) uniform UBO {
	// light/env/material parameters:
	vec4 eyePos;
	vec4 lightPos;
	vec4 lightColor;
	vec4 lightVector;
	
	// fog parameters:
	vec4 fogDistanceVector;
	vec4 fogDepthVector;
	vec4 fogEyeT;
	vec4 fogColor;
};
#endif

#if !defined(VK_BINDLESS_MODEL_VBO)
	layout(location = 0) in vec3 in_position;

	#if defined(USE_CL0_IDENT) || defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
	// use fixed color from frag.spec.constant.8
	#else
	layout(location = 1) in vec4 in_color0;
	#endif

	#ifndef USE_ENV
	layout(location = 2) in vec2 in_tex_coord0;
	#endif

	#ifdef USE_TX1
	layout(location = 3) in vec2 in_tex_coord1;
	#endif
	#ifdef USE_TX2
	layout(location = 4) in vec2 in_tex_coord2;
	#endif

	#if defined(USE_ENV) || defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
	layout(location = 5) in vec3 in_normal;
	#endif

	#if defined(USE_CL1) && !defined(USE_VBO_GHOUL2) && !defined(USE_VBO_MDV)
	layout(location = 6) in vec4 in_color1;
	#endif
	#if defined(USE_CL2) && !defined(USE_VBO_GHOUL2) && !defined(USE_VBO_MDV)
	layout(location = 7) in vec4 in_color2;
	#endif
#endif

#ifdef USE_CL0_IDENT
// use fixed color from frag.spec.constant.8
#else
layout(location = 0) out vec4 frag_color0;
#endif

#ifdef USE_CL1
layout(location = 5) out vec4 frag_color1;
#endif
#ifdef USE_CL2
layout(location = 6) out vec4 frag_color2;
#endif

layout(location = 1) out vec2 frag_tex_coord0;
#ifdef USE_TX1
layout(location = 2) out vec2 frag_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 3) out vec2 frag_tex_coord2;
#endif

#ifdef USE_FOG
layout(location = 4) out vec2 fog_tex_coord;
#endif


// pbr
// https://stackoverflow.com/questions/52139496/how-to-avoid-validation-layer-errors-about-unused-vertex-inputs


#if !defined(VK_BINDLESS_MODEL_VBO) && defined(USE_VBO_GHOUL2)
	layout(location = 10) in uvec4 in_bones;
	layout(location = 11) in vec4 in_weights;
#endif

layout(location = 10) flat out uint actual_draw_id;

#if defined(PER_PIXEL_LIGHTING) 
	layout(location = 8) in vec4 in_qtangent;

	#if !defined(USE_FAST_LIGHT)
		layout(location = 9) in vec4 in_lightdir;	// lightmap only?
		layout(location = 11) out vec4 var_Normal;
		layout(location = 12) out vec4 var_LightDir;
		layout(location = 13) out vec4 var_ViewDir;
		layout(location = 14) out flat int Var_RenderMode;
		layout(location = 15) out NTB out_ntb;
	#endif
#endif


#ifdef VK_BINDLESS_MODEL_VBO
	#define MODEL_MDXM_VERTEX_POSITION	0
	#define MODEL_MDXM_VERTEX_NORMAL	4
	#define MODEL_MDXM_VERTEX_TEXCOORD	8
	#define MODEL_MDXM_VERTEX_BONEREFS	10
	#define MODEL_MDXM_VERTEX_WEIGHTS	11
	#define MODEL_MDXM_VERTEX_TANGENTS	12
	#define MODEL_MDXM_VERTEX_SIZE		16

	#define MODEL_VERTEX_POSITION	0
	#define MODEL_VERTEX_NORMAL		4
	#define MODEL_VERTEX_TEXCOORD	8
	#define MODEL_VERTEX_TANGENTS	10
	#define MODEL_VERTEX_SIZE		14
#endif

out gl_PerVertex {
	vec4 gl_Position;
};

void main() {
	#ifdef VK_BINDLESS
		#if defined(VK_BINDLESS_MODEL_VBO) && (defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV))
			actual_draw_id = gl_InstanceIndex >> 16;
		#else
			actual_draw_id = draw_id;
		#endif
	#endif

	#if defined(VK_BINDLESS) && defined(USE_ENTITY_DATA)
		global_data = global[actual_draw_id];	// needs to be bound for fragment cus texture_idx[].
		entity_data = entities[global_data.entity_id];
	#endif

	vec3 position = vec3(0.0);
	vec3 normal = vec3(0.0);

	NTB ntb;

	#if defined(PER_PIXEL_LIGHTING)
		#if !defined(USE_FAST_LIGHT)
			QTangentToNTB( in_qtangent, ntb );
		#else
			if ( light_mode == LIGHT_MODE_VECTOR ) QTangentToNTB( in_qtangent, ntb );
		#endif
	#endif

	#if defined(USE_VBO_MDV)
		#ifdef VK_BINDLESS_MODEL_VBO
			int first_index = indirect[draw_id].first_index[gl_InstanceIndex & 0xFFFF];

			uint index_base  = first_index + gl_VertexIndex;
			uint idx = model_ibos[nonuniformEXT(global_data.vbo_model_index)].data[index_base];
			idx = idx * MODEL_VERTEX_SIZE;

			position = get_model_float3(global_data.vbo_model_index, idx + MODEL_VERTEX_POSITION);
			normal = get_model_float3(global_data.vbo_model_index, idx + MODEL_VERTEX_NORMAL);

			vec2 in_tex_coord0 = get_model_float2(global_data.vbo_model_index, idx + MODEL_VERTEX_TEXCOORD);

			if ( u_deform.type != 0 ){ // !DEFORM_NONE
				position	= DeformPosition( position, normal, frag_tex_coord0 );
				normal		= DeformNormal( position, normal );
			}

			vec2 in_tex_coord1 = vec2(0.0);
			vec2 in_tex_coord2 = vec2(0.0);
			vec4 in_color0 = vec4(0.0);
			vec4 in_color1 = vec4(0.0);
			vec4 in_color2 = vec4(0.0);
		#else
			position = in_position;
			normal = normalize(in_normal);

			if ( u_deform.type != 0 ){ // !DEFORM_NONE
				position	= DeformPosition( position, normal, frag_tex_coord0 );
				normal		= DeformNormal( position, normal );
			}
		#endif
	#elif defined(USE_VBO_GHOUL2)
		#ifdef VK_BINDLESS_MODEL_VBO
				int first_index = indirect[draw_id].first_index[gl_InstanceIndex & 0xFFFF];

				uint index_base  = first_index + gl_VertexIndex;
				uint idx = model_ibos[nonuniformEXT(global_data.vbo_model_index)].data[index_base];
				idx = idx * MODEL_MDXM_VERTEX_SIZE;

				mat4x3 skin_matrix = mat4x3(0);
				uint bone_indices =  get_model_uint(global_data.vbo_model_index, idx + MODEL_MDXM_VERTEX_BONEREFS);
				vec4 bone_weights =  unpackUnorm4x8(get_model_uint(global_data.vbo_model_index, idx + MODEL_MDXM_VERTEX_WEIGHTS));

				for (int i_bone = 0; i_bone < 4; i_bone++)
				{
					uint bone_index = ( bone_indices >> (i_bone * 8) ) & 0xFF;
					float bone_weight = bone_weights[i_bone];

					mat4x3 m = GetBoneMatrix( bone_index );
					skin_matrix += m * bone_weight;
				}

				position = get_model_float3(global_data.vbo_model_index, idx + MODEL_MDXM_VERTEX_POSITION);
				position = skin_matrix * vec4(position, 1.0);

				normal = get_model_float3(global_data.vbo_model_index, idx + MODEL_MDXM_VERTEX_NORMAL);

				vec2 in_tex_coord0 = get_model_float2(global_data.vbo_model_index, idx + MODEL_MDXM_VERTEX_TEXCOORD);

				vec2 in_tex_coord1 = vec2(0.0);
				vec2 in_tex_coord2 = vec2(0.0);
				vec4 in_color0 = vec4(0.0);
				vec4 in_color1 = vec4(0.0);
				vec4 in_color2 = vec4(0.0);
		#else
				mat4x3 skin_matrix =
					GetBoneMatrix(in_bones.x) * in_weights.x +
					GetBoneMatrix(in_bones.y) * in_weights.y +
					GetBoneMatrix(in_bones.z) * in_weights.z +
					GetBoneMatrix(in_bones.w) * in_weights.w;

				position = skin_matrix * vec4(in_position, 1.0);

				normal = normalize(skin_matrix * vec4(in_normal, 0.0));

				#if defined(PER_PIXEL_LIGHTING) && !defined(USE_FAST_LIGHT)
					ntb.tangent = normalize(skin_matrix * vec4(ntb.tangent, 0.0));	
				#endif
		#endif


		if ( u_deform.type != 0 ){ // !DEFORM_NONE
			position	= DeformPosition( position, normal, frag_tex_coord0 );
			normal		= DeformNormal( position, normal );
		}
	#else
		position = in_position;
		#if defined(USE_ENV)
			normal = in_normal;
		#endif

		#if defined(PER_PIXEL_LIGHTING)
			#if !defined(USE_FAST_LIGHT) 
				normal = ntb.normal;
			#else
				normal = (light_mode == LIGHT_MODE_VECTOR) ? ntb.normal : normal;
			#endif
		#endif
	#endif

	#ifndef USE_CL0_IDENT
		#if defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
			frag_color0 = CalcColor( 0, position, normal );
		#else
			frag_color0 = in_color0;
		#endif
	#endif
	#ifdef USE_CL1
		#if defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
			frag_color1 = CalcColor( 1, position, normal );
		#else
			frag_color1 = in_color1;
		#endif
	#endif
	#ifdef USE_CL2
		#if defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
			frag_color2 = CalcColor( 2, position, normal );
		#else
			frag_color2 = in_color2;
		#endif
	#endif

	#if defined(VK_BINDLESS) && defined(USE_ENTITY_DATA) && defined(VK_BINDLESS_BATCHED_INDIRECT)
		gl_Position = global_data.mvp * vec4(position, 1.0);
	#else
		gl_Position = mvp * vec4(position, 1.0);
	#endif

#ifdef USE_ENV
	vec3 viewer = normalize(eyePos.xyz - position);
	float d = dot(normal, viewer);
	vec2 reflected = normal.yz * 2 * d - viewer.yz;

	frag_tex_coord0.s = 0.5 + reflected.x * 0.5;
	frag_tex_coord0.t = 0.5 - reflected.y * 0.5;
#else
	frag_tex_coord0 = in_tex_coord0;
#endif

#ifdef USE_TX1
	frag_tex_coord1 = in_tex_coord1;
#endif
#ifdef USE_TX2
	frag_tex_coord2 = in_tex_coord2;
#endif

	// tcGen & tcMod
	#if defined(USE_VBO_GHOUL2) || defined(USE_VBO_MDV)
		#ifndef USE_ENV
			frag_tex_coord0 = GenTexCoords( in_tex_coord0.st, u_bundle[0].tcGen.type, position, normal, u_bundle[0].tcGen.vector0, u_bundle[0].tcGen.vector1 );
		#endif

		if ( u_bundle[0].numTexMods > 0 ) {
			frag_tex_coord0 = ModTexCoords( frag_tex_coord0, position, u_bundle[0].tcMod.matrix, u_bundle[0].tcMod.offTurb );
		}
		#ifdef USE_TX1
			if ( u_bundle[1].numTexMods > 0 ) {
				frag_tex_coord1 = ModTexCoords( frag_tex_coord1, position, u_bundle[1].tcMod.matrix, u_bundle[1].tcMod.offTurb );
			}
		#endif

		#ifdef USE_TX2
			if ( u_bundle[2].numTexMods > 0 ) {
				frag_tex_coord2 = ModTexCoords( frag_tex_coord2, position, u_bundle[2].tcMod.matrix, u_bundle[2].tcMod.offTurb );
			}
		#endif
	#endif

#ifdef USE_FOG
	float s = dot(position, fogDistanceVector.xyz) + fogDistanceVector.w;
	float t = dot(position, fogDepthVector.xyz) + fogDepthVector.w;

	if ( fogEyeT.y == 1.0 ) {
		if ( t < 0.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 31.0 / 32.0;
		}
	} else {
		if ( t < 1.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 1.0 / 32.0 + (30.0 / 32.0 * t) / ( t - fogEyeT.x );
		}
	}

	fog_tex_coord = vec2(s, t);
#endif

#ifdef PER_PIXEL_LIGHTING
	vec3 L;

	#if !defined(USE_FAST_LIGHT)
		position		= (u_ModelMatrix * vec4(position, 1.0)).xyz;
		normal			= normalize(mat3(u_ModelMatrix) * normal);

		if ( light_mode == LIGHT_MODE_VECTOR )
		{
			L	= u_LocalLightOrigin.xyz - (position * u_LocalLightOrigin.w);
			ntb.tangent	 = normalize(mat3(u_ModelMatrix) * ntb.tangent);
			ntb.binormal = normalize(mat3(u_ModelMatrix) * ntb.binormal);
		}
		else {
			L = in_lightdir.xyz * 2.0 - vec3(1.0);
			L = ( u_ModelMatrix * vec4( L, 0.0 ) ).xyz;
			L = normalize( ( L * 0.5 ) + vec3( 0.5 ) );
		}
	#else
		if ( light_mode == LIGHT_MODE_VECTOR )
		{
			position		= (u_ModelMatrix * vec4(position, 1.0)).xyz;
			normal			= normalize(mat3(u_ModelMatrix) * normal);

			L = u_LocalLightOrigin.xyz - (position * u_LocalLightOrigin.w);

			float sqrLightDist = dot(L, L);
			float NL = clamp(dot(normal, L) / sqrt(sqrLightDist), 0.0, 1.0);

			frag_color0.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;
			#ifdef USE_CL1
				frag_color1.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;
			#endif
			#ifdef USE_CL2
				frag_color2.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;
			#endif
		}
	#endif

	#if !defined(USE_FAST_LIGHT)
		vec3 viewDir = u_ViewOrigin.xyz - position;

		out_ntb = ntb;
		var_LightDir	= vec4(L, 0.0);	
		var_Normal		= vec4(normal, 0.0);
		var_ViewDir		= vec4(viewDir, 0.0);
	#endif
#endif
}
