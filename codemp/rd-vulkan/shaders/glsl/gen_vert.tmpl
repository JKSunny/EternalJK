#version 450

#ifdef USE_TX2
#define USE_TX1
#endif

#ifdef USE_CL2
#define USE_CL1
#endif

// 64 bytes
layout(push_constant) uniform Transform {
	mat4 mvp;
};


#if defined(USE_FOG) || defined(USE_ENV)
layout(set = 1, binding = 0) uniform UBO {
	// VERTEX
	vec4 eyePos;
	vec4 lightPos;
	//  VERTEX-FOG
	vec4 fogDistanceVector;
	vec4 fogDepthVector;
	vec4 fogEyeT;
	// FRAGMENT
	vec4 lightColor;
	vec4 fogColor;
	// linear dynamic light
	vec4 lightVector;
};
#endif

#ifdef USE_VBO_GHOUL2
layout(set = 1, binding = 1) uniform UBOG2 {
	vec4 eyePos2;
	vec4 ambientLight;
	vec4 directedLight;
	vec4 lightDir;
	vec4 rgbGen; 
	vec4 alphaGen;
	vec4 baseColor[3];
	vec4 vertColor[3];
	vec4 disintegrationInfo;
	vec4 deformInfo[3];
};	

#define M_PI 3.1415926535897932384626433832795
#ifdef USE_VBO_GHOUL2_RGBAGEN_CONSTS				// manually uncomment
layout (constant_id = 0) const int rgbaGen0 = 0;
layout (constant_id = 1) const int rgbaGen1 = 0;
layout (constant_id = 2) const int rgbaGen2 = 0;
const ivec3 rgbaGen = ivec3(rgbaGen0, rgbaGen1, rgbaGen2); 
#endif

layout(location = 10) out vec3 N;
layout(location = 11) out vec3 L;
layout(location = 12) out vec3 V;

layout(set = 1, binding = 2) uniform UBOG3 {
	mat4 modelMatrix;
	mat4 boneMatrices[20];
};
#endif


layout(location = 0) in vec3 in_position;

#if defined(USE_CL0_IDENT) || defined(USE_VBO_GHOUL2)
// use fixed color from frag.spec.constant.8
#else
layout(location = 1) in vec4 in_color0;
#endif

#ifndef USE_ENV
layout(location = 2) in vec2 in_tex_coord0;
#endif

#ifdef USE_TX1
layout(location = 3) in vec2 in_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 4) in vec2 in_tex_coord2;
#endif

#if defined(USE_ENV) || defined(USE_VBO_GHOUL2)
layout(location = 5) in vec3 in_normal;
#endif

#if defined(USE_CL1) && !defined(USE_VBO_GHOUL2)
layout(location = 6) in vec4 in_color1;
#endif
#if defined(USE_CL2) && !defined(USE_VBO_GHOUL2)
layout(location = 7) in vec4 in_color2;
#endif

#ifdef USE_VBO_GHOUL2
layout(location = 9) in vec4 in_bones;
layout(location = 10) in vec4 in_weights;
#endif

#ifdef USE_CL0_IDENT
// use fixed color from frag.spec.constant.8
#else
layout(location = 0) out vec4 frag_color0;
#endif

#ifdef USE_CL1
layout(location = 5) out vec4 frag_color1;
#endif
#ifdef USE_CL2
layout(location = 6) out vec4 frag_color2;
#endif

layout(location = 1) out vec2 frag_tex_coord0;
#ifdef USE_TX1
layout(location = 2) out vec2 frag_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 3) out vec2 frag_tex_coord2;
#endif

#ifdef USE_FOG
layout(location = 4) out vec2 fog_tex_coord;
#endif

#ifdef USE_VK_PBR
struct NTB {
	vec3 normal, tangent, binormal;
};

layout(location = 8) in vec4 in_qtangent;
layout(location = 9) out vec3 out_position;
layout(location = 13) out NTB out_ntb;

vec3 QuatTransVec( in vec4 quat, in vec3 vec ) {
	vec3 tmp = 2.0 * cross( quat.xyz, vec );
	return vec + quat.w * tmp + cross( quat.xyz, tmp );
}

void QTangentToNTB( in vec4 qtangent, out NTB ntb ) {
	ntb.normal = QuatTransVec( qtangent, vec3( 0.0, 0.0, 1.0 ) );
	ntb.tangent = QuatTransVec( qtangent, vec3( 1.0, 0.0, 0.0 ) );
	ntb.tangent *= sign( qtangent.w );
	ntb.binormal = QuatTransVec( qtangent, vec3( 0.0, 1.0, 0.0 ) );
}
#endif

out gl_PerVertex {
	vec4 gl_Position;
};

#ifdef USE_VBO_GHOUL2
vec4 CalcColor( int index, in vec3 position, in vec3 normal ) 
{
	vec4 color = ( vertColor[index] * vec4( 0.0 ) ) + baseColor[index];		// skip vertColor?

#ifdef USE_VBO_GHOUL2_RGBAGEN_CONSTS
	if( rgbaGen[index] != 1 )
		return color;
#endif

	switch ( int( rgbGen[index] ) ) {
		case 9:	// CGEN_LIGHTING_DIFFUSE;
		{
			break;
			float incoming = clamp( dot( normal, lightDir.xyz ), 0.0, 1.0 );
			color.rgb = clamp( directedLight.rgb * incoming + ambientLight.rgb, 0.0, 1.0 );
			break;
		}
		case 14:// CGEN_DISINTEGRATION_1
		{
			vec3 delta = disintegrationInfo.xyz - position;
			float sqrDistance = dot( delta, delta );

			if ( sqrDistance < disintegrationInfo.w )
				color *= 0.0;
			else if ( sqrDistance < disintegrationInfo.w + 60.0 )
				color *= vec4( 0.0, 0.0, 0.0, 1.0 );
			else if ( sqrDistance < disintegrationInfo.w + 150.0 )
				color *= vec4( 0.435295, 0.435295, 0.435295, 1.0 );
			else if ( sqrDistance < disintegrationInfo.w + 180.0 )
				color *= vec4( 0.6862745, 0.6862745, 0.6862745, 1.0 );

			return color;
		}
		case 15:// CGEN_DISINTEGRATION_2
		{
			vec3 delta = disintegrationInfo.xyz - position;
			float sqrDistance = dot( delta, delta );

			if ( sqrDistance < disintegrationInfo.w )
				return vec4(0.0);

			return color;
		}
	}

	switch ( int( alphaGen[index] ) ) {
		case 6: // AGEN_LIGHTING_SPECULAR
		{
			vec3 viewer = normalize( eyePos2.xyz - position );
			float d = dot( normal, viewer );
			vec3 lightDir = normalize( vec3(-960.0, 1980.0, 96.0) - position );
			vec3 reflected = -reflect( lightDir, normal * d - viewer );
			color.a = clamp( dot( reflected, normalize( viewer ) ), 0.0, 1.0 );
			break;
		}
		case 8: // AGEN_PORTAL
		{
			vec3 viewer = normalize( eyePos2.xyz - position );
			color.a = clamp( length( viewer ) / alphaGen[3], 0.0, 1.0 );
			break;
		}
	}

	return color;
}

float GetNoiseValue( float x, float y, float z, float t )
{
	// Variation on the 'one-liner random function'.
	// Not sure if this is still 'correctly' random
	return fract( sin( dot(
		vec4( x, y, z, t ),
		vec4( 12.9898, 78.233, 12.9898, 78.233 )
	)) * 43758.5453 );
}

float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )
{
	float value = phase + time * frequency;

	switch ( func ) {
		case 1: // GF_SIN
			return sin(value * 2.0 * M_PI);
		case 2: // GF_SQUARE
			return sign(0.5 - fract(value));
		case 3: // GF_TRIANGLE
			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
		case 4: // GF_SAWTOOTH
			return fract(value);
		case 5:	// GF_INVERSE_SAWTOOTH
			return 1.0 - fract(value);
		default:// GF_NONE
			return 0.0;
	}
}

vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )
{

	//deformInfo[0];	deformInfo[0][0];
	//deformInfo[1];	deformInfo[0][1];
	//deformInfo[2];	deformInfo[0][2];
	//deformInfo[3];	deformInfo[0][3];

	//deformInfo[4];	deformInfo[1][0];
	//deformInfo[5];	deformInfo[1][1];
	//deformInfo[6];	deformInfo[1][2];
	//deformInfo[7];	deformInfo[1][3];

	//deformInfo[8];	deformInfo[2][0];
	//deformInfo[9];	deformInfo[2][1];
	//deformInfo[10];	deformInfo[2][2];
	//deformInfo[11];	deformInfo[2][3];

	switch ( int( deformInfo[2][0] ) ) {
		default:
		{
			return pos;
		}

		case 3: // DEFORM_BULGE
		{
			float bulgeHeight = deformInfo[0][1]; // amplitude
			float bulgeWidth = deformInfo[0][2]; // phase
			float bulgeSpeed = deformInfo[0][3]; // frequency

			float scale = CalculateDeformScale( 1, deformInfo[1][3], bulgeWidth * st.x, bulgeSpeed );

			return pos + normal * scale * bulgeHeight;
		}

		case 4: // DEFORM_BULGE_UNIFORM
		{
			float bulgeHeight = deformInfo[0][1]; // amplitude

			return pos + normal * bulgeHeight;
		}

		case 1: // DEFORM_WAVE
		{
			float base = deformInfo[0][0];
			float amplitude = deformInfo[0][1];
			float phase = deformInfo[0][2];
			float frequency = deformInfo[0][3];
			float spread = deformInfo[1][0];

			float offset = dot( pos.xyz, vec3( spread ) );
			float scale = CalculateDeformScale( int(deformInfo[2][1]), deformInfo[1][3], phase + offset, frequency );

			return pos + normal * (base + scale * amplitude);
		}

		case 5: // DEFORM_MOVE
		{
			float base = deformInfo[0][0];
			float amplitude = deformInfo[0][1];
			float phase = deformInfo[0][2];
			float frequency = deformInfo[0][3];
			vec3 direction = vec3( deformInfo[1][0], deformInfo[1][1], deformInfo[1][2] );

			float scale = CalculateDeformScale( int(deformInfo[2][1]), deformInfo[1][3], phase, frequency );

			return pos + direction * (base + scale * amplitude);
		}

		case 6: // DEFORM_PROJECTION_SHADOW
		{
			vec3 ground = vec3(
				deformInfo[0][0],
				deformInfo[0][1],
				deformInfo[0][2]);
			float groundDist = deformInfo[0][3];
			vec3 lightDir = vec3(
				deformInfo[1][0],
				deformInfo[1][1],
				deformInfo[1][2]);

			float d = 1.0 / dot( lightDir, ground );
			vec3 lightPos = lightDir * d;
			return pos - lightPos * (dot( pos, ground ) + groundDist);
		}

		case 17: // DEFORM_DISINTEGRATION
		{
			vec3 delta = disintegrationInfo.xyz - pos;
			float sqrDistance = dot(delta, delta);
			vec3 normalScale = vec3(-0.01);
			if ( sqrDistance < disintegrationInfo.w )
			{
				normalScale = vec3(2.0, 2.0, 0.5);
			}
			else if ( sqrDistance < disintegrationInfo.w + 50 )
			{
				normalScale = vec3(1.0, 1.0, 0.0);
			}
			return pos + normal * normalScale;
		}
	}
}

vec3 DeformNormal( const in vec3 position, const in vec3 normal )
{
	if ( int( deformInfo[2][0] ) != 2 ) // DEFORM_NORMALS
		return normal;

	float amplitude = deformInfo[0][1];
	float frequency = deformInfo[0][3];

	vec3 outNormal = normal;
	const float scale = 0.98;

	outNormal.x += amplitude * GetNoiseValue(
		position.x * scale,
		position.y * scale,
		position.z * scale,
		deformInfo[1][3] * frequency );

	outNormal.y += amplitude * GetNoiseValue(
		100.0 * position.x * scale,
		position.y * scale,
		position.z * scale,
		deformInfo[1][3] * frequency );

	outNormal.z += amplitude * GetNoiseValue(
		200.0 * position.x * scale,
		position.y * scale,
		position.z * scale,
		deformInfo[1][3] * frequency );

	return outNormal;
}
#endif

void main() {
#ifdef USE_VK_PBR
	QTangentToNTB( in_qtangent, out_ntb );
	out_position = in_position;
#endif

#ifdef USE_VBO_GHOUL2
#ifndef USE_VK_PBR
	vec3 out_position = in_position;
#endif
	mat4 skin_matrix = 
		in_weights.x * boneMatrices[int(in_bones.x)] +
		in_weights.y * boneMatrices[int(in_bones.y)] +
		in_weights.z * boneMatrices[int(in_bones.z)] +
		in_weights.w * boneMatrices[int(in_bones.w)];

	
#ifdef USE_VK_PBR
	out_ntb.normal = normalize(transpose(inverse(mat3(modelMatrix * skin_matrix))) * out_ntb.normal);
	out_ntb.tangent = normalize(transpose(inverse(mat3(modelMatrix * skin_matrix))) * out_ntb.tangent);
	N = out_ntb.normal;
#else
	N = normalize(transpose(inverse(mat3(modelMatrix * skin_matrix))) * in_normal);
#endif
	L = (modelMatrix  * vec4(lightDir.xyz, 0.0)).rgb;
	V =	eyePos2.xyz - in_position;

	#ifdef USE_ENV
	vec3 viewer = normalize(eyePos.xyz - in_position);
	float d = dot(N, viewer); 
	vec2 reflected = N.yz * 2 * d - viewer.yz;

	frag_tex_coord0.s = 0.5 + reflected.x * 0.5;
	frag_tex_coord0.t = 0.5 - reflected.y * 0.5;
	#else
	frag_tex_coord0 = in_tex_coord0;
	#endif

	if( int( deformInfo[2][0] ) != 0 ){ // !DEFORM_NONE
		out_position	= DeformPosition( out_position, in_normal, frag_tex_coord0 );
		N			= DeformNormal( out_position, N );
	}

	gl_Position = mvp * skin_matrix * vec4(out_position, 1.0);

	#ifndef USE_CL0_IDENT
		frag_color0 = CalcColor( 0, out_position, N );
	#endif
	#ifdef USE_CL1
		frag_color1 = CalcColor( 1, out_position, N );
	#endif
	#ifdef USE_CL2
		frag_color2 = CalcColor( 2, out_position, N );
	#endif
#else
	gl_Position = mvp * vec4(in_position, 1.0);

	#ifdef USE_CL0_IDENT
	// use fixed color from frag.spec.constant.8
	#else
		frag_color0 = in_color0;
	#endif

	#ifdef USE_CL1
		frag_color1 = in_color1;
	#endif
	#ifdef USE_CL2
		frag_color2 = in_color2;
	#endif

	#ifdef USE_ENV
		vec3 viewer = normalize(eyePos.xyz - in_position);
		float d = dot(in_normal, viewer); 
		vec2 reflected = in_normal.yz * 2 * d - viewer.yz;

		frag_tex_coord0.s = 0.5 + reflected.x * 0.5;
		frag_tex_coord0.t = 0.5 - reflected.y * 0.5;
	#else
		frag_tex_coord0 = in_tex_coord0;
	#endif
#endif

#ifdef USE_TX1
	frag_tex_coord1 = in_tex_coord1;
#endif
#ifdef USE_TX2
	frag_tex_coord2 = in_tex_coord2;
#endif

#ifdef USE_FOG
	float s = dot(in_position, fogDistanceVector.xyz) + fogDistanceVector.w;
	float t = dot(in_position, fogDepthVector.xyz) + fogDepthVector.w;

	if ( fogEyeT.y == 1.0 ) {
		if ( t < 0.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 31.0 / 32.0;
		}
	} else {
		if ( t < 1.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 1.0 / 32.0 + (30.0 / 32.0 * t) / ( t - fogEyeT.x );
		}
	}

	fog_tex_coord = vec2(s, t);
#endif
}