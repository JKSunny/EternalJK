#version 450
#extension GL_GOOGLE_include_directive : enable

#define FRAGMENT_PROGRAM
#include "global.h"

#if defined (USE_FOG)
layout(set = 0, binding = 0) uniform UBO {
	// light/env/material parameters:
	vec4 eyePos;
	vec4 lightPos;
	vec4 lightColor;
	vec4 lightVector;
//#ifdef USE_FOG	
	// fog parameters:
	vec4 fogDistanceVector;
	vec4 fogDepthVector;
	vec4 fogEyeT;
	vec4 fogColor;
//#endif
};
#endif

#ifdef USE_CL0_IDENT
// use fixed color from spec.constant.8
#else
layout(location = 0) in vec4 frag_color0;
#endif

#ifdef USE_CL1
layout(location = 5) in vec4 frag_color1;
#endif
#ifdef USE_CL2
layout(location = 6) in vec4 frag_color2;
#endif

layout(location = 1) centroid in vec2 frag_tex_coord0;
#ifdef USE_TX1
layout(location = 2) centroid in vec2 frag_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 3) centroid in vec2 frag_tex_coord2;
#endif
#ifdef USE_FOG
layout(location = 4) in vec2 fog_tex_coord;
#endif

#ifdef USE_DF
layout(depth_less) out float gl_FragDepth;
#else
layout(location = 0) out vec4 out_color;
#endif

#ifdef USE_ATEST
layout (constant_id = 0) const int alpha_test_func = 0;
layout (constant_id = 1) const float alpha_test_value = 0.0;
#ifdef USE_DF
layout (constant_id = 2) const float depth_fragment = 0.85;
#endif
#endif

layout (constant_id = 3) const int alpha_to_coverage = 0;
//layout (constant_id = 4) const int color_mode = 0;
//layout (constant_id = 5) const int abs_light = 0;
#if defined (USE_TX1) || defined(USE_TX2)
layout (constant_id = 6) const int tex_mode = 0; // modulate, add (identity), add(non-identity) etc
#endif
layout (constant_id = 7) const int discard_mode = 0;
#ifdef USE_CL0_IDENT
layout (constant_id = 8) const float identity_color = 1.0;
#endif

// pbr
layout (constant_id = 12) const int vbo_mode = 0;
layout (constant_id = 13) const int light_mode = LIGHT_MODE_NONE;

layout(location = 10) flat in uint actual_draw_id;

#if defined(PER_PIXEL_LIGHTING) && !defined(USE_FAST_LIGHT)
	layout (location = 11) in vec4 var_Normal;
	layout (location = 12) in vec4 var_LightDir;
	layout (location = 13) in vec4 var_ViewDir;
	layout (location = 14) in flat int Var_RenderMode;
	layout (location = 15) in NTB in_ntb;
#endif



#include "texture.h"

void main() {
	#ifdef VK_BINDLESS
		#ifndef PER_PIXEL_LIGHTING
			global_data.texture_idx[0] = global[actual_draw_id].texture_idx[0];
			global_data.texture_idx[1] = global[actual_draw_id].texture_idx[1];
			global_data.texture_idx[2] = global[actual_draw_id].texture_idx[2];
			global_data.texture_idx[3] = global[actual_draw_id].texture_idx[3];
			global_data.texture_idx[4] = global[actual_draw_id].texture_idx[4];
			global_data.texture_idx[5] = global[actual_draw_id].texture_idx[5];
			global_data.texture_idx[6] = global[actual_draw_id].texture_idx[6];
			global_data.texture_idx[7] = global[actual_draw_id].texture_idx[7];
		#else
			global_data = global[actual_draw_id];
		#endif

		#ifdef USE_ENTITY_DATA
			entity_data = entities[global_data.entity_id];
		#endif
	#endif

	vec4 diffuse;
	float attenuation;
	vec3 viewDir, lightColor, ambientColor;
	vec3 L, N, E;

#ifdef USE_FOG
	//vec4 fog = texture(fog_texture, fog_tex_coord);
	vec4 fog = global_texture(fog_texture, fog_tex_coord);
#endif

#ifdef USE_CL0_IDENT
	vec4 color0 = global_texture(texture0, frag_tex_coord0) * vec4( identity_color );
#else
	vec4 color0 = global_texture(texture0, frag_tex_coord0) * frag_color0;
#endif

	vec4 base;

#if defined (USE_TX2)
#ifdef USE_CL2
	// soecial blend modes for non-identity colors
	if ( tex_mode == 1 || tex_mode == 2 )
	{
		// add
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 3 )
	{
		// modulate by alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		color0 *= color0.a;
		color1 *= color1.a;
		color2 *= color2.a;
		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 4 )
	{
		// modulate by 1.0-alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		color0 *= 1.0-color0.a;
		color1 *= 1.0-color1.a;
		color2 *= 1.0-color2.a;
		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 5 )
	{
		// mix by src alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		//base = mix( color0, color1, color1.a );
		//base = mix( base, color2, color2.a );
		base = mix( mix( color0, color1, color1.a ), color2, color2.a );
	}
	else if ( tex_mode == 6 )
	{
		// mix by 1-src alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		//base = mix( color1, color0, color1.a );
		//base = mix( color2, base, color2.a );
		base = mix( color2, mix( color1, color0, color1.a ), color2.a );
	}
	else if ( tex_mode == 7 ) // 0 + 2x GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_DST_COLOR
	{
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;

		base = (color2 + color2.a) * (color1 + color1.a) * color0;
	}
	else
	{
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color2;
		base = color0 * color1 * color2;
	}
#else
	// triple-texture blending
	if ( tex_mode == 1 )
	{
		// add (identity)
		vec4 color1 = global_texture(texture1, frag_tex_coord1);
		vec4 color2 = global_texture(texture2, frag_tex_coord2);
		base = vec4(color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a);
	}
	else if ( tex_mode == 2 )
	{
		// add
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color0;
		vec4 color2 = global_texture(texture2, frag_tex_coord2) * frag_color0;
		base = vec4(color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a);
	}
	else 
	{
		// default case, modulate
		vec4 color1 = global_texture(texture1, frag_tex_coord1);
		vec4 color2 = global_texture(texture2, frag_tex_coord2);
		base = color0 * color1 * color2;
	}
#endif // !USE_TX2
#elif defined(USE_TX1)
#ifdef USE_CL1
	// soecial blend modes for non-identity colors
	if ( tex_mode == 1 || tex_mode == 2 )
	{
		// add
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 3 ) // 2x GLS_DSTBLEND_ONE | GLS_SRCBLEND_SRC_ALPHA
	{
		// modulate by alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		color0 *= color0.a;
		color1 *= color1.a;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 4 ) // 2x GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA
	{
		// modulate by 1.0-alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		color0 *= 1.0-color0.a;
		color1 *= 1.0-color1.a;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 5 ) // 0 + GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_SRCBLEND_SRC_ALPHA
	{
		// mix by src alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		base = mix( color0, color1, color1.a );
	}
	else if ( tex_mode == 6 ) // 0 + GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA
	{
		// mix by 1-src alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		base = mix( color1, color0, color1.a );
	}
	else if ( tex_mode == 7 ) // 0 + GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_DST_COLOR
	{
		// modulate color1 by color0
		// moduleta color0 by color1.alpha
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		base = (color1 + color1.a) * color0;
	}
	else
	{
		// default case, modulate
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color1;
		base = color0 * color1;
	}
#else
	// double-texture blending
	if ( tex_mode == 1 )
	{
		// add (identity)
		vec4 color1 = global_texture(texture1, frag_tex_coord1);
		base = vec4(color0.rgb + color1.rgb, color0.a * color1.a);
	}
	else if ( tex_mode == 2 )
	{
		// add
		vec4 color1 = global_texture(texture1, frag_tex_coord1) * frag_color0;
		base = vec4(color0.rgb + color1.rgb, color0.a * color1.a);
	}
	else // default case
	{
		// modulate
		vec4 color1 = global_texture(texture1, frag_tex_coord1);
		base = color0 * color1;
	}
#endif // !USE_CL1
#endif // !USE_TX1

#ifdef USE_ATEST
	if (alpha_to_coverage != 0) {
		if (alpha_test_func == 1) {
			base.a =  base.a > 0.0 ? 1.0 : 0.0;
		} else if (alpha_test_func == 2) {
			base.a = CorrectAlpha(alpha_test_value, 1.0 - base.a, frag_tex_coord0);
		} else if (alpha_test_func == 3) {
			base.a = CorrectAlpha(alpha_test_value, base.a, frag_tex_coord0);
		}
	} else
	// specialization: alpha-test function
	if (alpha_test_func == 1) {
		if (color0.a == alpha_test_value) discard;
	} else if (alpha_test_func == 2) {
		if (color0.a >= alpha_test_value) discard;
	} else if (alpha_test_func == 3) {
		if (color0.a < alpha_test_value) discard;
	}
#endif

#if !defined(USE_TX1) && !defined(USE_TX2)
	base = color0;
#endif

	if ( discard_mode == 1 ) {
		if ( base.a == 0.0 ) {
			discard;
		}
	} else if ( discard_mode == 2 ) {
		if ( dot( base.rgb, base.rgb ) == 0.0 ) {
			discard;
		}
	}

#ifdef USE_DF
	if ( base.a < depth_fragment )
		discard;

	gl_FragDepth = gl_FragCoord.z;
#else
	
	#if defined(PER_PIXEL_LIGHTING) && !defined(USE_FAST_LIGHT)
		viewDir = var_ViewDir.xyz;
		E = normalize(viewDir);

		L = var_LightDir.xyz;
		float sqrLightDist = dot(L, L);
		L /= sqrt(sqrLightDist);
		
		#if defined(USE_TX1)
			if ( light_mode == LIGHT_MODE_LIGHTMAP )
			{
				vec3 lightmapColor = global_texture(texture1, frag_tex_coord1).rgb;
				lightColor    = lightmapColor * frag_color0.rgb;
				diffuse       = color0;
				ambientColor  = vec3(0.0);
				attenuation   = 1.0;
			} else
		#endif
		if ( light_mode == LIGHT_MODE_VECTOR )
		{
			lightColor    = u_directedLight.rgb;
			ambientColor  = u_ambientLight.rgb;
			diffuse       = base;
			attenuation   = 1.0;
		} 
		else if ( light_mode == LIGHT_MODE_VERTEX )
		{ 
			lightColor    = vec3(1.0);
			ambientColor  = vec3(0.0);
			diffuse       = base;
			attenuation   = 1.0;
		}

		N = CalcNormal(var_Normal.xyz, frag_tex_coord0);

		if ( light_mode == LIGHT_MODE_LIGHTMAP || light_mode == LIGHT_MODE_VERTEX ) {
			ambientColor  = lightColor;
			float surfNL  = clamp(dot(var_Normal.xyz, L), 0.0, 1.0);
			lightColor   /= max(surfNL, 0.25);
			ambientColor  = max(ambientColor - lightColor * surfNL, 0.0);
		}

		lightColor *= PI;

		vec4 specular = vec4( 1.0 );
		float roughness = 0.99;
		float AO = 1.0;

		// metallic roughness workflow
		if ( physical_texture_set < 0 )
		{
			vec4 ORMS = global_texture( physical_texture, frag_tex_coord0 );
			ORMS.xyzw *= u_SpecularScale.zwxy;
			specular.rgb = mix( vec3( 0.08 ) * ORMS.w, diffuse.rgb, ORMS.z );
			diffuse.rgb *= vec3( 1.0 - ORMS.z );

			roughness = mix( 0.01, 1.0, ORMS.y );
			AO = min( ORMS.x, AO );
		} 
		
		// specular gloss workflow
		else 
		{
			specular = global_texture( physical_texture, frag_tex_coord0 );
			specular.rgb *= u_SpecularScale.xyz;
			roughness = mix( 1.0, 0.01, specular.a * ( 1.0 - u_SpecularScale.w ) );
		}


		ambientColor *= AO;

		vec3  H  = normalize( L + E );
		float NE = abs( dot( N, E ) ) + 1e-5;
		float NL = clamp( dot( N, L ), 0.0, 1.0 );
		float LH = clamp( dot( L, H ), 0.0, 1.0 );

		vec3  Fd = CalcDiffuse( diffuse.rgb, NE, NL, LH, roughness );
		vec3  Fs = vec3( 0.0 );

		float NH = clamp( dot( N, H ), 0.0, 1.0 );
		float VH = clamp( dot( E, H ), 0.0, 1.0 );
		Fs = CalcSpecular( specular.rgb, NH, NL, NE, LH, VH, roughness );

		vec3 reflectance = Fd + Fs;

		out_color.rgb  = lightColor * reflectance * ( attenuation * NL );
		out_color.rgb += ambientColor * diffuse.rgb;

		#ifdef VK_DLIGHT_GPU
			out_color.rgb += CalcDynamicLightContribution(roughness, N, E, u_ViewOrigin.xyz, viewDir, NE, diffuse.rgb, specular.rgb, var_Normal.xyz);
		#endif

		if ( env_texture_set > -1 )
			out_color.rgb += CalcIBLContribution( roughness, N, E, NE, specular.rgb * AO );

		out_color.a = diffuse.a;
	#else
		out_color = base;
	#endif

	#if defined(USE_FOG)
		out_color = mix( out_color, fog * fogColor, fog.a );
	#endif
#endif
}